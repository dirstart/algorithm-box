<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0"
  >
  <title>é«˜çº§é…’å§éŸ³ä¹å¯è§†åŒ–</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      color: white;
      font-family: 'Arial', sans-serif;
    }

    canvas {
      display: block;
    }

    .controls {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 10px;
      z-index: 100;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    button {
      background: linear-gradient(45deg, #ff00cc, #3333ff);
      border: none;
      color: white;
      padding: 12px 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 8px 4px;
      cursor: pointer;
      border-radius: 25px;
      font-weight: bold;
      box-shadow: 0 4px 15px rgba(255, 0, 204, 0.3);
      transition: all 0.3s ease;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 0, 204, 0.4);
    }

    select {
      padding: 10px;
      border-radius: 20px;
      margin-left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
      font-size: 14px;
      outline: none;
    }

    .title {
      position: absolute;
      bottom: 20px;
      left: 20px;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.5);
    }
  </style>
</head>

<body>
  <div class="controls">
    <button id="startButton">ğŸ¤ å¯åŠ¨éŸ³ä¹æ•æ‰</button>
    <select id="visualizerSelect">
      <option value="neonTunnel">éœ“è™¹éš§é“</option>
      <option value="liquidDrops">æ¶²æ€éŸ³æ³¢</option>
      <option value="fractalEnergy">åˆ†å½¢èƒ½é‡</option>
      <option value="holographicBars">å…¨æ¯é¢‘è°±</option>
      <option value="cosmicPulse">å®‡å®™è„‰åŠ¨</option>
    </select>
  </div>
  <canvas id="visualizer"></canvas>
  <div class="title">é…’å§éŸ³ä¹å®æ—¶å¯è§†åŒ–ç³»ç»Ÿ v2.0</div>

  <script>
    // è·å–DOMå…ƒç´ 
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');
    const startButton = document.getElementById('startButton');
    const visualizerSelect = document.getElementById('visualizerSelect');

    // è®¾ç½®ç”»å¸ƒå¤§å°ä¸ºçª—å£å¤§å°
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();

    // éŸ³é¢‘åˆ†æç›¸å…³å˜é‡
    let audioContext;
    let analyser;
    let microphone;
    let dataArray;
    let timeDataArray;
    let animationId;
    let isPlaying = false;

    // å¯è§†åŒ–ç±»å‹
    let visualizerType = 'neonTunnel';

    // ç‰¹æ•ˆå‚æ•°
    const effects = {
      neonTunnel: {
        rotation: 0,
        segments: 120,
        maxRadius: 0
      },
      liquidDrops: {
        drops: [],
        dropCount: 30
      },
      fractalEnergy: {
        branches: [],
        lastSpawn: 0
      },
      holographicBars: {
        rotation: 0,
        depth: 200
      },
      cosmicPulse: {
        pulses: [],
        stars: []
      }
    };

    // åˆå§‹åŒ–ç‰¹æ•ˆ
    function initEffects() {
      // æ¶²æ€éŸ³æ³¢æ•ˆæœåˆå§‹åŒ–
      for (let i = 0; i < effects.liquidDrops.dropCount; i++) {
        effects.liquidDrops.drops.push({
          x: Math.random() * canvas.width,
          y: canvas.height + Math.random() * 100,
          size: Math.random() * 15 + 5,
          speed: Math.random() * 3 + 1,
          color: `hsla(${Math.random() * 60 + 180}, 100%, 50%, ${Math.random() * 0.5 + 0.3})`,
          rippleSize: 0,
          rippling: false
        });
      }

      // å®‡å®™è„‰åŠ¨æ•ˆæœåˆå§‹åŒ–
      for (let i = 0; i < 200; i++) {
        effects.cosmicPulse.stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * 1.5,
          brightness: Math.random() * 0.5 + 0.5
        });
      }
    }

    initEffects();

    // å¼€å§‹éº¦å…‹é£è¾“å…¥
    startButton.addEventListener('click', async () => {
      if (isPlaying) {
        stopAudio();
        startButton.textContent = 'ğŸ¤ å¯åŠ¨éŸ³ä¹æ•æ‰';
        isPlaying = false;
        return;
      }

      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 512;

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        microphone = audioContext.createMediaStreamSource(stream);
        microphone.connect(analyser);

        dataArray = new Uint8Array(analyser.frequencyBinCount);
        timeDataArray = new Uint8Array(analyser.fftSize);

        startButton.textContent = 'â¹ åœæ­¢æ•æ‰';
        isPlaying = true;

        // å¼€å§‹åŠ¨ç”»å¾ªç¯
        animate();
      } catch (error) {
        console.error('Error accessing microphone:', error);
        alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·ç¡®ä¿å·²æˆäºˆæƒé™ã€‚é”™è¯¯: ' + error.message);
      }
    });

    // ç›‘å¬å¯è§†åŒ–ç±»å‹å˜åŒ–
    visualizerSelect.addEventListener('change', () => {
      visualizerType = visualizerSelect.value;
      // é‡ç½®ç”»å¸ƒèƒŒæ™¯
      ctx.fillStyle = 'rgba(0, 0, 0, 1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    });

    // åœæ­¢éŸ³é¢‘
    function stopAudio() {
      if (microphone) {
        microphone.disconnect();
      }
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
    }

    // åŠ¨ç”»å¾ªç¯
    function animate() {
      animationId = requestAnimationFrame(animate);

      // è·å–é¢‘ç‡æ•°æ®
      analyser.getByteFrequencyData(dataArray);
      analyser.getByteTimeDomainData(timeDataArray);

      // æ ¹æ®é€‰æ‹©çš„ç±»å‹æ¸²æŸ“ä¸åŒçš„å¯è§†åŒ–æ•ˆæœ
      switch (visualizerType) {
        case 'neonTunnel':
          drawNeonTunnel();
          break;
        case 'liquidDrops':
          drawLiquidDrops();
          break;
        case 'fractalEnergy':
          drawFractalEnergy();
          break;
        case 'holographicBars':
          drawHolographicBars();
          break;
        case 'cosmicPulse':
          drawCosmicPulse();
          break;
      }
    }

    // 1. éœ“è™¹éš§é“æ•ˆæœ
    function drawNeonTunnel() {
      // åŠé€æ˜èƒŒæ™¯åˆ›é€ æ‹–å°¾æ•ˆæœ
      ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      effects.neonTunnel.maxRadius = Math.min(canvas.width, canvas.height) * 0.45;
      effects.neonTunnel.rotation += 0.002;

      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(effects.neonTunnel.rotation);

      const segmentAngle = (Math.PI * 2) / effects.neonTunnel.segments;
      const bassAvg = getFrequencyRangeAverage(0, 10);

      for (let i = 0; i < effects.neonTunnel.segments; i++) {
        const angle = i * segmentAngle;
        const freqIndex = Math.floor((i / effects.neonTunnel.segments) * dataArray.length);
        const value = dataArray[freqIndex] / 255;
        const radius = effects.neonTunnel.maxRadius * (0.7 + value * 0.3);

        const x1 = Math.cos(angle) * (effects.neonTunnel.maxRadius * 0.5);
        const y1 = Math.sin(angle) * (effects.neonTunnel.maxRadius * 0.5);
        const x2 = Math.cos(angle) * radius;
        const y2 = Math.sin(angle) * radius;

        // åˆ›å»ºéœ“è™¹å‘å…‰æ•ˆæœ
        const hue = (i * 3 + Date.now() * 0.01) % 360;
        const glow = value * 20 + bassAvg * 30;

        // ç»˜åˆ¶å‘å…‰çº¿æ¡
        ctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${0.2 + value * 0.8})`;
        ctx.lineWidth = 2 + value * 8;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        // æ·»åŠ å‘å…‰æ•ˆæœ
        ctx.shadowBlur = glow;
        ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
        ctx.strokeStyle = `hsla(${hue}, 100%, 80%, 0.8)`;
        ctx.lineWidth = 1 + value * 3;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.shadowBlur = 0;

        // åœ¨æœ«ç«¯æ·»åŠ å…‰ç‚¹
        if (value > 0.5) {
          ctx.fillStyle = `hsla(${hue}, 100%, 80%, ${value})`;
          ctx.beginPath();
          ctx.arc(x2, y2, value * 5, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      ctx.restore();

      // ä¸­å¿ƒèƒ½é‡çƒ
      const centerGlow = bassAvg * 50;
      ctx.shadowBlur = centerGlow;
      ctx.shadowColor = 'rgba(100, 200, 255, 0.8)';
      ctx.fillStyle = 'rgba(150, 220, 255, 0.6)';
      ctx.beginPath();
      ctx.arc(centerX, centerY, 10 + bassAvg * 30, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    // 2. æ¶²æ€éŸ³æ³¢æ•ˆæœ
    function drawLiquidDrops() {
      // åŠé€æ˜èƒŒæ™¯åˆ›é€ æ‹–å°¾æ•ˆæœ
      ctx.fillStyle = 'rgba(0, 0, 10, 0.1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const bassValue = getFrequencyRangeAverage(0, 5) * 2;
      const midValue = getFrequencyRangeAverage(20, 40);
      const highValue = getFrequencyRangeAverage(80, 100);

      // æ›´æ–°å’Œç»˜åˆ¶æ¶²æ»´
      for (let i = 0; i < effects.liquidDrops.drops.length; i++) {
        const drop = effects.liquidDrops.drops[i];

        // éšæœºè§¦å‘æ³¢çº¹æ•ˆæœ
        if (!drop.rippling && Math.random() < highValue * 0.01) {
          drop.rippling = true;
          drop.rippleSize = 0;
        }

        // æ¶²æ»´ä¸‹è½
        drop.y -= drop.speed * (1 + bassValue * 0.5);
        if (drop.y < -drop.size * 2) {
          drop.y = canvas.height + Math.random() * 100;
          drop.x = Math.random() * canvas.width;
          drop.rippling = false;
        }

        // ç»˜åˆ¶æ¶²æ»´
        const dropHue = 200 + Math.sin(Date.now() * 0.001 + i) * 30;
        ctx.fillStyle = `hsla(${dropHue}, 100%, 60%, 0.7)`;
        ctx.beginPath();
        ctx.ellipse(drop.x, drop.y, drop.size, drop.size * 1.5, 0, 0, Math.PI * 2);
        ctx.fill();

        // ç»˜åˆ¶æ¶²æ»´åº•éƒ¨é«˜å…‰
        ctx.fillStyle = `hsla(${dropHue}, 100%, 80%, 0.4)`;
        ctx.beginPath();
        ctx.ellipse(drop.x, drop.y + drop.size * 0.7,
          drop.size * 0.6, drop.size * 0.3, 0, 0, Math.PI * 2);
        ctx.fill();

        // ç»˜åˆ¶æ³¢çº¹æ•ˆæœ
        if (drop.rippling) {
          const rippleAlpha = 1 - (drop.rippleSize / 100);
          if (rippleAlpha > 0) {
            ctx.strokeStyle = `hsla(${dropHue}, 100%, 70%, ${rippleAlpha * 0.6})`;
            ctx.lineWidth = 2 + midValue * 0.5;
            ctx.beginPath();
            ctx.arc(drop.x, drop.y, drop.rippleSize, 0, Math.PI * 2);
            ctx.stroke();
            drop.rippleSize += 1 + highValue * 0.1;
          } else {
            drop.rippling = false;
          }
        }
      }

      // åº•éƒ¨éŸ³æ³¢çº¿
      const waveHeight = canvas.height * 0.1;
      const waveY = canvas.height - waveHeight * 0.5;

      ctx.lineWidth = 2;
      ctx.strokeStyle = `hsla(200, 100%, 60%, 0.8)`;
      ctx.beginPath();

      for (let x = 0; x < canvas.width; x += 5) {
        const index = Math.floor((x / canvas.width) * timeDataArray.length);
        const value = timeDataArray[index] / 128.0;
        const y = waveY - (value * waveHeight);

        if (x === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }

      ctx.stroke();

      // æ·»åŠ æ°´é¢åå°„æ•ˆæœ
      const gradient = ctx.createLinearGradient(0, waveY - waveHeight, 0, waveY + waveHeight);
      gradient.addColorStop(0, 'hsla(200, 100%, 60%, 0.1)');
      gradient.addColorStop(1, 'hsla(200, 100%, 60%, 0.4)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, waveY - waveHeight, canvas.width, waveHeight * 2);
    }

    // 3. åˆ†å½¢èƒ½é‡æ•ˆæœ
    function drawFractalEnergy() {
      // é»‘è‰²èƒŒæ™¯
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const bassValue = getFrequencyRangeAverage(0, 5);
      const highValue = getFrequencyRangeAverage(80, 100);

      // æ ¹æ®ä½é¢‘ç”Ÿæˆæ–°åˆ†æ”¯
      const now = Date.now();
      if (now - effects.fractalEnergy.lastSpawn > 200 && bassValue > 0.3) {
        const angle = Math.random() * Math.PI * 2;
        const length = 5 + bassValue * 50;
        const speed = 1 + bassValue * 3;
        const hue = Math.random() * 360;

        effects.fractalEnergy.branches.push({
          x: centerX,
          y: centerY,
          angle: angle,
          length: length,
          speed: speed,
          hue: hue,
          age: 0,
          maxAge: 50 + Math.random() * 100,
          segments: []
        });

        effects.fractalEnergy.lastSpawn = now;
      }

      // æ›´æ–°å’Œç»˜åˆ¶åˆ†æ”¯
      for (let i = effects.fractalEnergy.branches.length - 1; i >= 0; i--) {
        const branch = effects.fractalEnergy.branches[i];
        branch.age++;

        if (branch.age >= branch.maxAge) {
          effects.fractalEnergy.branches.splice(i, 1);
          continue;
        }

        // è®¡ç®—æ–°ä½ç½®
        const newX = branch.x + Math.cos(branch.angle) * branch.speed;
        const newY = branch.y + Math.sin(branch.angle) * branch.speed;

        // éšæœºæ”¹å˜è§’åº¦
        if (Math.random() < 0.1) {
          branch.angle += (Math.random() - 0.5) * 0.3;
        }

        // æ ¹æ®é«˜é¢‘å¢åŠ åˆ†å‰
        if (branch.segments.length < 5 && Math.random() < highValue * 0.02) {
          effects.fractalEnergy.branches.push({
            x: branch.x,
            y: branch.y,
            angle: branch.angle + (Math.random() - 0.5) * 1,
            length: branch.length * 0.8,
            speed: branch.speed * 0.9,
            hue: (branch.hue + Math.random() * 30 - 15) % 360,
            age: branch.age,
            maxAge: branch.maxAge * 0.8,
            segments: []
          });
        }

        // ä¿å­˜çº¿æ®µ
        branch.segments.push({
          x1: branch.x,
          y1: branch.y,
          x2: newX,
          y2: newY
        });

        // æ›´æ–°ä½ç½®
        branch.x = newX;
        branch.y = newY;

        // ç»˜åˆ¶åˆ†æ”¯
        const alpha = 1 - (branch.age / branch.maxAge);
        const lineWidth = 1 + (branch.length / 10) * alpha;

        for (let j = 0; j < branch.segments.length; j++) {
          const seg = branch.segments[j];
          const segAlpha = alpha * (j / branch.segments.length);

          ctx.strokeStyle = `hsla(${branch.hue}, 100%, 60%, ${segAlpha})`;
          ctx.lineWidth = lineWidth * (j / branch.segments.length);
          ctx.beginPath();
          ctx.moveTo(seg.x1, seg.y1);
          ctx.lineTo(seg.x2, seg.y2);
          ctx.stroke();

          // æ·»åŠ å‘å…‰æ•ˆæœ
          if (j === branch.segments.length - 1) {
            ctx.shadowBlur = lineWidth * 2;
            ctx.shadowColor = `hsla(${branch.hue}, 100%, 50%, ${segAlpha * 0.5})`;
            ctx.stroke();
            ctx.shadowBlur = 0;
          }
        }

        // åœ¨æœ«ç«¯æ·»åŠ èƒ½é‡çƒ
        if (branch.segments.length > 5) {
          const lastSeg = branch.segments[branch.segments.length - 1];
          const glowSize = lineWidth * 3 * alpha;

          ctx.fillStyle = `hsla(${branch.hue}, 100%, 70%, ${alpha * 0.7})`;
          ctx.beginPath();
          ctx.arc(lastSeg.x2, lastSeg.y2, glowSize, 0, Math.PI * 2);
          ctx.fill();

          ctx.shadowBlur = glowSize * 3;
          ctx.shadowColor = `hsla(${branch.hue}, 100%, 50%, ${alpha * 0.3})`;
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }

      // ä¸­å¿ƒèƒ½é‡æº
      const centerSize = 10 + bassValue * 40;
      const centerHue = (Date.now() * 0.05) % 360;

      ctx.fillStyle = `hsla(${centerHue}, 100%, 70%, 0.8)`;
      ctx.beginPath();
      ctx.arc(centerX, centerY, centerSize, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = centerSize * 2;
      ctx.shadowColor = `hsla(${centerHue}, 100%, 50%, 0.5)`;
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    // 4. å…¨æ¯é¢‘è°±æ•ˆæœ
    function drawHolographicBars() {
      // åŠé€æ˜èƒŒæ™¯åˆ›é€ æ‹–å°¾æ•ˆæœ
      ctx.fillStyle = 'rgba(0, 0, 20, 0.1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      effects.holographicBars.rotation += 0.003;

      const barCount = 60;
      const maxBarHeight = canvas.height * 0.4;
      const radius = Math.min(canvas.width, canvas.height) * 0.3;

      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(effects.holographicBars.rotation);

      // ç»˜åˆ¶3Dé¢‘è°±æŸ±
      for (let i = 0; i < barCount; i++) {
        const angle = (i / barCount) * Math.PI * 2;
        const freqIndex = Math.floor((i / barCount) * dataArray.length);
        const value = dataArray[freqIndex] / 255;
        const barHeight = value * maxBarHeight;

        // è®¡ç®—3Dä½ç½®
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        const z = 0;

        // 3DæŠ•å½±
        const scale = effects.holographicBars.depth / (effects.holographicBars.depth + z);
        const px = x * scale;
        const py = y * scale;

        // é¢œè‰²å’Œé€æ˜åº¦
        const hue = (i * 6 + Date.now() * 0.05) % 360;
        const alpha = 0.3 + value * 0.7;

        // ç»˜åˆ¶æŸ±çŠ¶å›¾
        const barWidth = 5 * scale;
        ctx.fillStyle = `hsla(${hue}, 100%, 60%, ${alpha})`;
        ctx.beginPath();
        ctx.moveTo(px - barWidth / 2, py);
        ctx.lineTo(px + barWidth / 2, py);
        ctx.lineTo(px + barWidth / 2, py - barHeight * scale);
        ctx.lineTo(px - barWidth / 2, py - barHeight * scale);
        ctx.closePath();
        ctx.fill();

        // æ·»åŠ é¡¶éƒ¨é«˜å…‰
        if (value > 0.3) {
          ctx.fillStyle = `hsla(${hue}, 100%, 80%, ${alpha * 0.7})`;
          ctx.beginPath();
          ctx.moveTo(px - barWidth / 2, py - barHeight * scale);
          ctx.lineTo(px + barWidth / 2, py - barHeight * scale);
          ctx.lineTo(px, py - (barHeight + 5) * scale);
          ctx.closePath();
          ctx.fill();
        }

        // æ·»åŠ è¿æ¥çº¿
        if (i > 0) {
          const prevAngle = ((i - 1) / barCount) * Math.PI * 2;
          const prevX = Math.cos(prevAngle) * radius;
          const prevY = Math.sin(prevAngle) * radius;
          const prevScale = effects.holographicBars.depth / (effects.holographicBars.depth + z);
          const prevPx = prevX * prevScale;
          const prevPy = prevY * prevScale;

          ctx.strokeStyle = `hsla(${(hue + 180) % 360}, 100%, 60%, ${alpha * 0.3})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(prevPx, prevPy - (dataArray[freqIndex - 1] / 255) * maxBarHeight * prevScale);
          ctx.lineTo(px, py - barHeight * scale);
          ctx.stroke();
        }
      }

      ctx.restore();

      // æ·»åŠ ä¸­å¿ƒå…¨æ¯çƒ
      const bassValue = getFrequencyRangeAverage(0, 5);
      const centerSize = 20 + bassValue * 50;
      const centerHue = (Date.now() * 0.1) % 360;

      // çƒä½“å‘å…‰æ•ˆæœ
      ctx.shadowBlur = centerSize * 2;
      ctx.shadowColor = `hsla(${centerHue}, 100%, 50%, 0.5)`;
      ctx.fillStyle = `hsla(${centerHue}, 100%, 70%, 0.6)`;
      ctx.beginPath();
      ctx.arc(centerX, centerY, centerSize, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // çƒä½“ç½‘æ ¼çº¿
      ctx.strokeStyle = `hsla(${centerHue}, 100%, 80%, 0.4)`;
      ctx.lineWidth = 1;
      for (let i = 0; i < 10; i++) {
        const angle = (i / 10) * Math.PI * 2 + Date.now() * 0.001;
        ctx.beginPath();
        ctx.arc(centerX, centerY, centerSize, angle, angle + Math.PI);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(centerX, centerY, centerSize * 0.7, angle, angle + Math.PI);
        ctx.stroke();
      }
    }

    // 5. å®‡å®™è„‰åŠ¨æ•ˆæœ
    function drawCosmicPulse() {
      // æ¸å˜é»‘è‰²èƒŒæ™¯
      const gradient = ctx.createRadialGradient(
        canvas.width / 2, canvas.height / 2, 0,
        canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) / 2
      );
      gradient.addColorStop(0, 'rgba(0, 5, 20, 0.8)');
      gradient.addColorStop(1, 'rgba(0, 0, 5, 1)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const bassValue = getFrequencyRangeAverage(0, 10);
      const midValue = getFrequencyRangeAverage(40, 60);
      const highValue = getFrequencyRangeAverage(80, 100);

      // ç»˜åˆ¶æ˜Ÿæ˜Ÿ
      for (const star of effects.cosmicPulse.stars) {
        const twinkle = Math.sin(Date.now() * 0.001 + star.x) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness * twinkle * 0.8})`;
        ctx.fillRect(star.x, star.y, star.size, star.size);
      }

      // æ ¹æ®ä½é¢‘ç”Ÿæˆè„‰å†²æ³¢
      if (bassValue > 0.3 && Math.random() < 0.1) {
        const hue = Math.random() * 60 + 200;
        effects.cosmicPulse.pulses.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: 10,
          maxSize: 50 + bassValue * 200,
          speed: 1 + bassValue * 2,
          hue: hue,
          alpha: 0.8
        });
      }

      // æ ¹æ®é«˜é¢‘ç”Ÿæˆå°è„‰å†²
      if (highValue > 0.5 && Math.random() < 0.3) {
        const hue = Math.random() * 60 + 240;
        effects.cosmicPulse.pulses.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: 5,
          maxSize: 20 + highValue * 50,
          speed: 2 + highValue * 3,
          hue: hue,
          alpha: 0.6
        });
      }

      // æ›´æ–°å’Œç»˜åˆ¶è„‰å†²æ³¢
      for (let i = effects.cosmicPulse.pulses.length - 1; i >= 0; i--) {
        const pulse = effects.cosmicPulse.pulses[i];
        pulse.size += pulse.speed;

        if (pulse.size >= pulse.maxSize) {
          effects.cosmicPulse.pulses.splice(i, 1);
          continue;
        }

        const currentAlpha = pulse.alpha * (1 - pulse.size / pulse.maxSize);

        // ç»˜åˆ¶è„‰å†²æ³¢
        ctx.strokeStyle = `hsla(${pulse.hue}, 100%, 70%, ${currentAlpha})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(pulse.x, pulse.y, pulse.size, 0, Math.PI * 2);
        ctx.stroke();

        // æ·»åŠ å‘å…‰æ•ˆæœ
        ctx.shadowBlur = 15;
        ctx.shadowColor = `hsla(${pulse.hue}, 100%, 50%, ${currentAlpha * 0.5})`;
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      // ä¸­å¿ƒé»‘æ´
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const blackHoleSize = 30 + bassValue * 20;

      // é»‘æ´å¸ç§¯ç›˜
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(Date.now() * 0.0005);

      for (let i = 0; i < 3; i++) {
        const diskSize = blackHoleSize * (1 + i * 0.5);
        const diskHue = (Date.now() * 0.05 + i * 40) % 360;

        ctx.strokeStyle = `hsla(${diskHue}, 100%, 50%, ${0.3 + midValue * 0.5})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, diskSize, 0, Math.PI * 2);
        ctx.stroke();

        // æ·»åŠ ä¸è§„åˆ™éƒ¨åˆ†
        for (let j = 0; j < 5; j++) {
          const angle = (j / 5) * Math.PI * 2 + Date.now() * 0.001 * i;
          const flareSize = diskSize * (0.8 + Math.sin(Date.now() * 0.001) * 0.2);

          ctx.strokeStyle = `hsla(${diskHue}, 100%, 70%, ${0.6 + midValue * 0.3})`;
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.arc(0, 0, flareSize, angle, angle + 0.3);
          ctx.stroke();
        }
      }

      ctx.restore();

      // é»‘æ´æœ¬ä½“
      const gradientHole = ctx.createRadialGradient(
        centerX, centerY, blackHoleSize * 0.5,
        centerX, centerY, blackHoleSize
      );
      gradientHole.addColorStop(0, 'rgba(0, 0, 0, 1)');
      gradientHole.addColorStop(0.7, 'rgba(50, 50, 100, 0.8)');
      gradientHole.addColorStop(1, 'rgba(100, 100, 200, 0)');

      ctx.fillStyle = gradientHole;
      ctx.beginPath();
      ctx.arc(centerX, centerY, blackHoleSize, 0, Math.PI * 2);
      ctx.fill();

      // é»‘æ´å¼•åŠ›é€é•œæ•ˆæœ
      ctx.strokeStyle = `rgba(100, 150, 255, 0.3)`;
      ctx.lineWidth = 1;
      for (let i = 0; i < 10; i++) {
        const ringSize = blackHoleSize * (1.5 + i * 0.3);
        ctx.beginPath();
        ctx.arc(centerX, centerY, ringSize, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    // è¾…åŠ©å‡½æ•°ï¼šè·å–é¢‘ç‡èŒƒå›´å¹³å‡å€¼
    function getFrequencyRangeAverage(start, end) {
      if (!dataArray || start >= end) return 0;

      start = Math.max(0, Math.min(dataArray.length - 1, start));
      end = Math.max(0, Math.min(dataArray.length - 1, end));

      let sum = 0;
      for (let i = start; i <= end; i++) {
        sum += dataArray[i] / 255;
      }

      return sum / (end - start + 1);
    }

    // çª—å£å¤§å°æ”¹å˜æ—¶è°ƒæ•´ç”»å¸ƒå¤§å°
    window.addEventListener('resize', () => {
      resizeCanvas();
    });
  </script>
</body>

</html>
